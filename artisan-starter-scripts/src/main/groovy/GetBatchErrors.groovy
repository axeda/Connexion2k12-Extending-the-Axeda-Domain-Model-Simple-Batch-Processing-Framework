import com.axeda.drm.sdk.scripto.Request
import groovy.json.JsonOutput
import com.axeda.platform.sdk.v1.services.extobject.ExtendedObject
import com.axeda.platform.sdk.v1.services.extobject.ExtendedObjectService
import com.axeda.platform.sdk.v1.services.extobject.ExtendedObjectSearchCriteria
import groovy.json.JsonSlurper
import com.axeda.platform.sdk.v1.services.ServiceFactory
import com.axeda.sdk.v2.dsl.Bridges
import org.apache.commons.lang.exception.ExceptionUtils
import net.sf.json.JSONObject

/**
 * GetBatchErrors
 *
 * Returns a set of errors generated by the batch processing framework during processing (if any).
 *
 * Request Contract:
 *
 * {
 *     "criteria": { "id": 1337 }
 * }
 *
 * Success Response Contract:
 *
 * {
 *     "resultType": "success",
 *     "result": [
 *          {
 *              "taskNumber": 3,
 *              "errorCount": 2,
 *              "reasons": [
 *                  "model name was too long",
 *                  "serial number was already in use."
 *              ]
 *          },
 *          {
 *              "taskNumber": 7,
 *              "errorCount": 1,
 *              "reasons": ["serial number was already in use."]
 *          }
 *     ]
 * }
 *
 * Error Response Contract:
 *
 * {
 *      "resultType": "error",
 *      "result": [
 *          {
 *              "id": "1234",
 *              "time": 0,
 *              "message": "An example error."
 *          }
 *      ]
 * }
 *
 * @author philip lombardi <plombardi@axeda.com>
 */

String mock         = Request.parameters.mock
String mockError    = Request.parameters.mockError
String contentType  = "application/json"

//
// mock data
//
Map mockRequest = [
    criteria: [id: 1337]
]

Map mockResponse = [
    resultType: "success",
    result: [
        [
            taskNumber: 3,
            errorCount: 2,
            reasons: [
                "model name was too long",
                "serial number was already in use."
            ]
        ],
        [
            taskNumber: 7,
            errorCount: 1,
            reasons: [
                "serial number was already in use."
            ]
        ]
    ]
]

Map mockErrorResponse = [
    resultType: "error",
    result: [
        [
            name: "",
            id: 1234,
            time: new Date().time,
            reason: "An example error."
        ]
    ]
]

Map response    = [:]
List errors     = []

try {
    //
    // mock switches
    //
    if (mock)       { return createReturnMap(contentType, mockResponse) }
    if (mockError)  { return createReturnMap(contentType, mockErrorResponse) }

    //
    // service validations
    //
    def requestBody = new JsonSlurper().parseText(Request.body) as Map

    //
    // service implementation logic.
    //
    def eoSvc = new ServiceFactory().extendedObjectService
    def criteria = requestBody.criteria

    def batchErrors = findBatchErrors(queryCriteria: criteria, eoSvc)

    response = createResponse(response: response, result: createBatchErrorList(batchErrors), errors: errors)
}
catch (any) {
    processFatalException(throwable: any, response: response)
}

return createReturnMap(contentType, response)

private List<ExtendedObject> findBatchErrors(args, ExtendedObjectService eoSvc){
    def criteria = new ExtendedObjectSearchCriteria()
    criteria.extendedObjectClassName = "connexion.batch.ErrorAnchor"
    criteria.internalObjectId = args.queryCriteria.id as Long
    return eoSvc.findExtendedObjects(criteria, -1, -1, null)
}

private List createBatchErrorList(List<ExtendedObject> batchErrors) {
    def listBridge = Bridges.extendedListBridge
    def reasonsListNameMaker = { batchID, taskNumber -> return "BER:${batchID}:${taskNumber}" }

    return batchErrors.collect {
        logInfo(message: "messagesListID = ${it.getPropertyByName("messagesListID").value}")
        logInfo(message: "messages = ${listBridge.find(it.getPropertyByName("messagesListID").value)?.list}")


        [
            taskNumber: it.getPropertyByName("taskNumber").value as Integer,
            inceptionTime: it.getPropertyByName("inceptionTime").value as Long,
            reasons: listBridge.find(it.getPropertyByName("messagesListID").value)?.list
        ]
    }
}

//
// Service Utility Methods
//

private Map createReturnMap(String contentType, output) {
    return ['Content-Type': contentType, Content: JSONObject.fromObject(output).toString(2)]
}

private Map processFatalException(args) {
    logError(message: ExceptionUtils.getFullStackTrace(args.throwable as Throwable))
    createError(args.errors, "0001", "Fatal execution exception. Check logs or contact your system administrator.")
}

private void createError(List errors, String errorID, String message) {
    errors << [id: errorID, time: new Date().time, message: message]
}

private void createInfo(List infos, String message) {
    infos << [time: new Date().time, message: message]
}

private void logInfo(args) {
    logger.info args.message
}

private void logError(args) {
    logger.error args.message
}

//
// Service Response Methods
//

private Map createResponse(args) {
    return !args.errors ? createSuccessResponse(args) : createErrorResponse(args)
}

private Map createSuccessResponse(args) {
    return [
        resultType: "success",
        result: args.result
    ]
}

private Map createErrorResponse(args) {
    return [
        resultType: "error",
        result: args.errors,
    ]
}


